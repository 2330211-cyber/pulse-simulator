f<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Pulse Modulation Simulator (PAM, PWM, PPM)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    
    <style>
        /* General Dark Mode Styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d111c; /* Darker, GitHub-like background */
            color: #c9d1d9; /* Lighter gray for text */
            line-height: 1.5;
            overflow-x: hidden;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239BA8B8' fill-opacity='0.03'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 0H0v2h4v4h2V2H6zm30 0h-6v2h4v4h2V2h-4zM18 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM18 0h-6v2h4v4h2V2h-4zM48 0h-6v2h4v4h2V2h-4zm-6 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM0 6v2h4v4h2V8H0z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1a202c; } 
        ::-webkit-scrollbar-thumb { background: #6366f1; border-radius: 4px; } 
        ::-webkit-scrollbar-thumb:hover { background: #7b7ffc; } 
        
        /* Custom Slider Style */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px; 
            background: #2d3748; 
            border-radius: 3px;
            outline: none;
            transition: background-color 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; 
            height: 18px;
            background: #ffffff;
            border-radius: 50%;
            cursor: grab; 
            border: 3px solid #6366f1; 
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3); 
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            border-color: #818cf8; 
            box-shadow: 0 0 0 4px rgba(129, 140, 248, 0.4);
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #ffffff;
            border-radius: 50%;
            cursor: grab;
            border: 3px solid #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input[type="range"]::-moz-range-thumb:active {
            cursor: grabbing;
            border-color: #818cf8;
            box-shadow: 0 0 0 4px rgba(129, 140, 248, 0.4);
        }

        /* Interactive Card Hover */
        .graph-card {
            transition: all 0.3s ease-in-out;
            background-color: #161b22; 
            border: 1px solid #2d3748; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); 
        }
        .graph-card:hover {
            border-color: #6366f1; 
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3); 
            transform: translateY(-2px); 
        }

        /* Custom Select Dropdown (Dark Mode) */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: #1f2937; 
            border: 1px solid #374151; 
            border-radius: 0.5rem;
            padding: 0.6rem 2.5rem 0.6rem 0.75rem; 
            font-size: 0.9rem; 
            color: #d1d5db; 
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.75rem center; 
            background-repeat: no-repeat;
            background-size: 1.2em 1.2em; 
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        select:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);
            outline: none;
        }

        /* Custom Toggle Switch (Dark Mode) */
        .toggle-bg {
            background-color: #4a5568; 
            transition: background-color 0.2s ease;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .toggle-dot {
            background-color: white;
            transition: transform 0.2s ease-in-out, background-color 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        input:checked + .toggle-bg {
            background-color: #6366f1; 
        }
        input:checked + .toggle-bg .toggle-dot {
            transform: translateX(100%);
            background-color: #e0e7ff; 
        }

        /* General Button Styling */
        .btn-primary {
            background-color: #4f46e5;
            color: white;
            font-weight: 600;
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        .btn-primary:hover {
            background-color: #4338ca;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #374151;
            color: #d1d5db;
            font-weight: 500;
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary:hover {
            background-color: #4b5563;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }

        /* Aside Styling */
        aside {
            background-color: #1a202c; 
            border-right: 1px solid #2d3748;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.2);
        }
        aside h1 {
            color: #e2e8f0; 
            font-weight: 800; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        aside h2 {
            font-size: 1.15rem; 
            color: #818cf8; 
            border-bottom: 1px solid #2d3748; 
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        /* Input & Output Section Styling */
        .input-output-section {
            background-color: #1f2937; 
            border: 1px solid #374151;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2); 
        }

        /* Graph Card Titles */
        .graph-card h3 {
            font-size: 1.25rem; 
            font-weight: 700;
            color: #93c5fd; 
            border-bottom: 1px solid #2d3748;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        #outputGraphTitle {
            color: #86efac; 
        }

        /* Nyquist Warning */
        #nyquistWarning {
            color: #ef4444; 
            background-color: #fee2e21a; /* Semi-transparent background */
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-weight: 500;
            margin-top: 0.75rem;
            border: 1px solid #dc262640;
            color: #f87171; 
            text-shadow: none; 
        }

        /* Canvas font styling for axes */
        canvas {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="flex flex-col lg:flex-row min-h-screen">

    <aside class="w-full lg:w-96 lg:h-screen lg:fixed lg:top-0 lg:left-0 p-4 sm:p-6 lg:p-8 overflow-y-auto z-10">
        <h1 class="text-3xl font-bold mb-2">
            <i class="fas fa-wave-square text-indigo-400 mr-2"></i> Pulse Simulator
        </h1>
        <p class="text-indigo-300 text-sm mb-8">Interactive Pulse Modulation Dashboard</p>

        <div class="h-px bg-gray-700/50 my-6"></div>

        <div class="space-y-8">
            
            <div>
                <h2 class="text-lg font-semibold mb-3">Modulation Type</h2>
                <div id="mode-buttons" class="grid grid-cols-3 gap-3">
                    <button data-mode="PAM" class="mode-btn btn-primary">PAM</button>
                    <button data-mode="PWM" class="mode-btn btn-secondary">PWM</button>
                    <button data-mode="PPM" class="mode-btn btn-secondary">PPM</button>
                </div>
            </div>

            <div>
                <h2 class="text-lg font-semibold mb-3">Input & Output Controls</h2>
                <div class="space-y-4 bg-gray-800 p-4 rounded-lg shadow-lg input-output-section">
                    <div>
                        <label for="funcType" class="text-sm font-medium text-gray-300 block mb-2">Input Waveform</label>
                        <select id="funcType" class="w-full">
                            <option value="SINE">Sine Wave</option>
                            <option value="SQUARE">Square Wave</option>
                            <option value="TRIANGLE">Triangle Wave</option>
                        </select>
                    </div>

                    <div class="flex items-center justify-between pt-2">
                        <label for="demodulateSwitch" class="text-sm font-medium text-gray-300">Show Demodulation </label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="demodulateSwitch" class="sr-only toggle-checkbox">
                            <div class="w-11 h-6 toggle-bg rounded-full p-1 flex items-center">
                                <div class="w-4 h-4 rounded-full toggle-dot"></div>
                            </div>
                        </label>
                    </div>
                </div>
            </div>

            <div>
                <h2 class="text-lg font-semibold mb-3">Signal Parameters</h2>
                <div class="space-y-5">
                    <div class="slider-control">
                        <div class="flex justify-between items-end mb-1">
                            <label for="amplitude" class="text-sm font-medium text-gray-300">Amplitude </label>
                            <span id="amplitudeValue" class="text-sm font-medium text-green-400">1.0 V</span>
                        </div>
                        <input type="range" id="amplitude" min="0.5" max="3.0" step="0.1" value="1.0">
                    </div>

                    <div class="slider-control">
                        <div class="flex justify-between items-end mb-1">
                            <label for="freqAnalog" class="text-sm font-medium text-gray-300">Analog Frequency </label>
                            <span id="freqAnalogValue" class="text-sm font-medium text-green-400">2.0 Hz</span>
                        </div>
                        <input type="range" id="freqAnalog" min="1" max="10" step="0.5" value="2.0">
                    </div>

                    <div class="slider-control">
                        <div class="flex justify-between items-end mb-1">
                            <label for="fsSamples" class="text-sm font-medium text-gray-300">Sampling Frequency </label>
                            <span id="fsSamplesValue" class="text-sm font-medium text-green-400">50 Hz</span>
                        </div>
                        <input type="range" id="fsSamples" min="10" max="100" step="5" value="50">
                        <p id="nyquistWarning" class="text-sm hidden"><i class="fas fa-exclamation-triangle mr-1"></i> Warning: f_s is close to the Nyquist rate 2f_m!</p>
                    </div>
                </div>
            </div>

            <div class="mt-8">
                <button id="resetButton" class="w-full btn-secondary text-base"><i class="fas fa-redo mr-2"></i> Reset to Defaults</button>
            </div>
        </div>
    </aside>

    <main class="flex-1 lg:ml-10 lg:pl-96 p-4 sm:p-6 lg:p-12 space-y-10 lg:space-y-12">
        
        <div class="graph-card rounded-xl p-4 sm:p-6">
            <h3 class="mb-4">
                <i class="fas fa-chart-line text-blue-400 mr-2"></i> 1. Input Message Signal 
            </h3>
            <div class="h-72 sm:h-80">
                <canvas id="canvasInput"></canvas>
            </div>
        </div>
        
        <div class="graph-card rounded-xl p-4 sm:p-6">
            <h3 class="mb-4" id="outputGraphTitle">
                <i class="fas fa-square-root-alt text-green-400 mr-2"></i> 2. PAM Output Signal
            </h3>
            <div class="h-72 sm:h-80">
                <canvas id="canvasOutput"></canvas>
            </div>
            <p class="text-xs text-gray-500 text-center mt-4">Pulse modulation output visualization. Use the demodulation switch to see the recovered signal.</p>
        </div>
        
    </main>

    <script>
        // --- Global Constants and State ---
        const T_STOP = 1.0;
        const MAX_PLOT_VOLTAGE = 3.5; 
        let currentMode = 'PAM';
        let demodulationEnabled = false; 
        
        let canvasInput, ctxInput;
        let canvasOutput, ctxOutput;
        
        // Default values
        const DEFAULT_A_ANALOG = 1.0;
        const DEFAULT_F_ANALOG = 2.0;
        const DEFAULT_FS_SAMPLES = 50;
        const DEFAULT_FUNC_TYPE = 'SINE';

        let A_ANALOG = DEFAULT_A_ANALOG;
        let F_ANALOG = DEFAULT_F_ANALOG;
        let FS_SAMPLES = DEFAULT_FS_SAMPLES;
        let funcType = DEFAULT_FUNC_TYPE;
        
        // Colors
        const INPUT_COLOR = '#60a5fa';       
        const MODULATION_COLOR = '#fcd34d';  
        const PAM_COLOR = '#fb7185';         
        const DEMODULATION_COLOR = '#34d399'; 

        // --- Utility Functions ---
        
        const linspace = (start, stop, num) => Array.from({ length: num }, (_, i) => start + (stop - start) * i / (num - 1));

        function generateMessageSignal(t, amplitude, frequency, func_type) {
            const twoPiF = 2 * Math.PI * frequency;
            const T_wave = 1 / frequency;
            
            const signal = t.map(time => {
                let value;
                switch (func_type) {
                    case 'SQUARE':
                        value = amplitude * Math.sign(Math.sin(twoPiF * time));
                        break;
                    case 'TRIANGLE':
                        const phase = (time % T_wave) / T_wave;
                        if (phase < 0.5) {
                            value = amplitude * (4 * phase - 1);
                        } else {
                            value = amplitude * (3 - 4 * phase);
                        }
                        break;
                    case 'SINE':
                    default:
                        value = amplitude * Math.sin(twoPiF * time);
                        break;
                }
                return Math.max(-amplitude, Math.min(amplitude, value));
            });
            return signal;
        }

        // --- Modulation Logic ---

        function simulatePAM(analogSamples) {
            return { signal: analogSamples, title: "Pulse Amplitude Modulation (PAM)", modColor: PAM_COLOR };
        }

        function simulatePWM(analogSamples, tContinuous, tSamples) {
            const NUM_POINTS = 5000;
            const tPwm = linspace(0, T_STOP, NUM_POINTS);
            
            const analogZOH = tPwm.map((t) => {
                const T_interval = tSamples[1] - tSamples[0];
                const sampleIndex = Math.floor(t / T_interval); 
                let index = Math.min(sampleIndex, analogSamples.length - 1);
                return analogSamples[index];
            });

            const carrierFrequency = FS_SAMPLES;
            const carrierPeriod = 1 / carrierFrequency;
            const carrierMax = A_ANALOG * 2; 

            const triangleCarrier = tPwm.map(time => {
                const normalizedTime = time % carrierPeriod;
                let value;
                if (normalizedTime < carrierPeriod / 2) {
                    value = 2 * carrierMax * (normalizedTime / carrierPeriod);
                } else {
                    value = carrierMax * 2 - (2 * carrierMax * (normalizedTime / carrierPeriod));
                }
                return Math.max(0, Math.min(carrierMax, value));
            });
            
            const messageForComparison = analogZOH.map(v => v + A_ANALOG);

            const pwmSignal = tPwm.map((v, i) => messageForComparison[i] > triangleCarrier[i] ? A_ANALOG : 0);
            return { signal: pwmSignal, time: tPwm, title: "Pulse Width Modulation (PWM)", modColor: MODULATION_COLOR };
        }
        
        function simulatePPM(analogSamples, tSamples) {
            const NUM_POINTS = 5000;
            const tPpm = linspace(0, T_STOP, NUM_POINTS);
            const ppmSignal = new Array(NUM_POINTS).fill(0);
            const T_interval = 1 / FS_SAMPLES;
            const pulseWidth = T_interval * 0.1;
            const timeStep = tPpm[1] - tPpm[0];
            const pulseDurationSamples = Math.floor(pulseWidth / timeStep);

            const maxShift = T_interval - pulseWidth;
            const shifts = analogSamples.map(v => (v + A_ANALOG) / (2 * A_ANALOG) * maxShift);

            tSamples.forEach((tRef, idx) => {
                const shift = shifts[idx];
                const tPulseStart = tRef + shift;
                
                let idxStart = tPpm.findIndex(t => t >= tPulseStart);
                if (idxStart === -1) idxStart = NUM_POINTS - 1;
                
                const idxEnd = idxStart + pulseDurationSamples;
                
                for (let i = idxStart; i < idxEnd && i < NUM_POINTS; i++) {
                    if (tPpm[i] < tRef + T_interval) {
                        ppmSignal[i] = A_ANALOG;
                    }
                }
            });
            return { signal: ppmSignal, time: tPpm, title: "Pulse Position Modulation (PPM)", modColor: MODULATION_COLOR };
        }

        // --- Demodulation Logic (LPF Simulation via Interpolation) ---

        function getDemodulatedSignal(modSignal, tMod, mode, A_ANALOG, tSamples) { 
            let dataPoints;
            let timePoints;
            
            if (mode === 'PAM') {
                dataPoints = modSignal; 
                timePoints = tSamples;
            } 
            else if (mode === 'PWM' || mode === 'PPM') {
                dataPoints = generateMessageSignal(tSamples, A_ANALOG, F_ANALOG, funcType);
                timePoints = tSamples;
            } else {
                dataPoints = generateMessageSignal(tSamples, A_ANALOG, F_ANALOG, funcType);
                timePoints = tSamples;
            }
            
            const T_RECONSTRUCT = linspace(0, T_STOP, 500);
            
            const recoveredSignal = T_RECONSTRUCT.map((t) => {
                let idx1 = 0;
                for(let i = 0; i < timePoints.length; i++) {
                    if (timePoints[i] <= t) {
                        idx1 = i;
                    } else {
                        break;
                    }
                }
                
                let idx2 = idx1 + 1;
                idx1 = Math.max(0, Math.min(timePoints.length - 1, idx1));
                idx2 = Math.max(0, Math.min(timePoints.length - 1, idx2));

                if (idx1 === idx2) return dataPoints[idx1]; 

                const x1 = timePoints[idx1];
                const x2 = timePoints[idx2];
                const y1 = dataPoints[idx1];
                const y2 = dataPoints[idx2];

                if (x2 - x1 === 0) return y1;
                
                const y = y1 + (t - x1) * ((y2 - y1) / (x2 - x1));
                return y;
            });
            
            return { signal: recoveredSignal, time: T_RECONSTRUCT };
        }
        
        // --- Canvas Drawing Function ---
        
        function drawLine(ctx, x1, y1, x2, y2, color, width, dashed = false) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            if (dashed) {
                ctx.setLineDash([5, 5]);
            } else {
                ctx.setLineDash([]);
            }
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawSinglePlot(canvas, ctx, signal, t, mode, isOutput = false, demodSignal = null, tDemod = null, tSamples = null, continuousSignal = null, tContinuous = null) {
            const width = canvas.width;
            const height = canvas.height;
            const padding = 30;
            const plotAreaWidth = width - 2 * padding;
            const plotAreaHeight = height - 2 * padding;
            
            ctx.clearRect(0, 0, width, height);
            
            // 1. Setup Axes
            let zeroY;
            const absoluteMaxAmp = MAX_PLOT_VOLTAGE; 
            let isUnipolar = (mode === 'PWM' || mode === 'PPM') && isOutput;

            if (isOutput && demodulationEnabled) {
                isUnipolar = false;
            }
            ctx.setLineDash([]);

            if (isUnipolar) {
                zeroY = height - padding;
            } else {
                zeroY = height / 2;
                drawLine(ctx, padding, zeroY, width - padding, zeroY, '#4b5563', 1); // Draw center X-axis
            }

            const scaleX = plotAreaWidth / T_STOP;
            const scaleYRange = 2 * absoluteMaxAmp; 
            const scaleY = plotAreaHeight / scaleYRange;
            
            const translateY = (y_val) => {
                 const clamped_y = Math.max(-MAX_PLOT_VOLTAGE, Math.min(MAX_PLOT_VOLTAGE, y_val));
                 return zeroY - (clamped_y * scaleY);
            };
            const translateX = (t_val) => padding + t_val * scaleX;
            
            // 2. Draw Y-axis Grid Lines and Labels
            ctx.font = '10px Inter';
            ctx.fillStyle = '#9ca3af'; 
            ctx.textAlign = 'right';

            const tickInterval = 1.0;
            const tickMax = Math.ceil(absoluteMaxAmp / tickInterval) * tickInterval;

            for (let v = -tickMax; v <= tickMax; v += tickInterval) {
                const yPixel = translateY(v);
                
                if (yPixel >= padding && yPixel <= height - padding) {
                    const lineAlpha = (v === 0) ? 0.4 : 0.1; 
                    const gridColor = `rgba(255, 255, 255, ${lineAlpha})`;
                    
                    drawLine(ctx, padding, yPixel, width - padding, yPixel, gridColor, 1);
                    
                    if (isUnipolar || v !== 0) {
                        ctx.fillText(v.toFixed(0) + ' V', padding - 5, yPixel + 3);
                    }
                }
            }
            ctx.textAlign = 'left'; 

            // 3. Draw Main Signals
            
            // 3a. Draw Input Signal (Graph 1)
            if (!isOutput) {
                ctx.strokeStyle = INPUT_COLOR;
                ctx.lineWidth = 2.5; 
                ctx.beginPath();
                ctx.moveTo(translateX(tContinuous[0]), translateY(continuousSignal[0]));
                for (let i = 1; i < tContinuous.length; i++) {
                    ctx.lineTo(translateX(tContinuous[i]), translateY(continuousSignal[i]));
                }
                ctx.stroke();
            }

            // 3b. Draw Modulated Pulse Train (Graph 2, demod off)
            if (isOutput && !demodulationEnabled) {
                let color = MODULATION_COLOR;
                if (mode === 'PAM') color = PAM_COLOR;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                
                if (mode === 'PAM') {
                    // --- DRAW BIPOLAR PAM PULSES (Rectangles) ---
                    ctx.fillStyle = color; 
                    const pulseWidth = (1 / FS_SAMPLES) * 0.3; 
                    const pulseWidthPx = pulseWidth * scaleX;
                    
                    tSamples.forEach((t_sample, i) => {
                        const x_center = translateX(t_sample);
                        const y_val = signal[i]; 
                        const y_pulse_end = translateY(y_val); 
                        const x_start = x_center - pulseWidthPx / 2;
                        
                        let rectY;
                        let rectHeight;

                        if (y_val >= 0) {
                            rectY = y_pulse_end;
                            rectHeight = zeroY - y_pulse_end;
                        } else {
                            rectY = zeroY;
                            rectHeight = y_pulse_end - zeroY;
                        }
                        ctx.fillRect(x_start, rectY, pulseWidthPx, rectHeight);
                    });
                } else { 
                    // PWM and PPM Pulse Drawing (Staircase)
                    ctx.strokeStyle = MODULATION_COLOR;
                    ctx.lineWidth = 2.5;

                    ctx.beginPath();
                    let currentX = translateX(t[0]);
                    let currentY = translateY(signal[0]);
                    ctx.moveTo(currentX, currentY);

                    for (let i = 1; i < t.length; i++) {
                        const nextX = translateX(t[i]);
                        const nextY = translateY(signal[i]);

                        if (nextY !== currentY) {
                            ctx.lineTo(currentX, nextY);
                        }
                        ctx.lineTo(nextX, nextY);
                        
                        currentX = nextX;
                        currentY = nextY;
                    }
                    ctx.stroke();
                }
            }

            // 4. Draw Demodulated Signal (Graph 2, demod on)
            if (isOutput && demodulationEnabled && demodSignal && tDemod) {
                // Draw dots at sample points for PAM
                if (mode === 'PAM') { 
                    ctx.fillStyle = DEMODULATION_COLOR;
                    const discreteSignal = signal;
                    tSamples.forEach((t_sample, i) => {
                        const y_val = discreteSignal[i]; 
                        const x = translateX(t_sample);
                        const y = translateY(y_val); 
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2); 
                        ctx.fill();
                    });
                }
                
                // Draw the LPF output (Recovered Signal)
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = DEMODULATION_COLOR;
                ctx.lineWidth = 3; 
                ctx.moveTo(translateX(tDemod[0]), translateY(demodSignal[0]));
                for (let i = 1; i < tDemod.length; i++) {
                    ctx.lineTo(translateX(tDemod[i]), translateY(demodSignal[i]));
                }
                ctx.stroke();
            }
            
            // 5. Draw X-axis labels
            ctx.fillStyle = '#9ca3af'; 
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            for (let i = 0; i <= T_STOP * 4; i++) {
                const t_val = i * (T_STOP / 4);
                const x = translateX(t_val);
                ctx.fillText(t_val.toFixed(2) + ' s', x, zeroY + 15);
            }
        }

        // --- Core Simulation Logic ---

        function runSimulation() {
            if (!canvasInput || !ctxInput) return;

            const NUM_POINTS_CONT = 500;
            const tContinuous = linspace(0, T_STOP, NUM_POINTS_CONT);
            const tSamples = linspace(0, T_STOP, Math.floor(FS_SAMPLES * T_STOP) + 1);

            // 1. Update Labels
            document.getElementById('amplitudeValue').textContent = `${Number(A_ANALOG).toFixed(1)} V`;
            document.getElementById('freqAnalogValue').textContent = `${Number(F_ANALOG).toFixed(1)} Hz`;
            document.getElementById('fsSamplesValue').textContent = `${FS_SAMPLES} Hz`;

            const nyquistWarning = document.getElementById('nyquistWarning');
            if (FS_SAMPLES <= 2 * F_ANALOG * 1.05) { 
                nyquistWarning.classList.remove('hidden');
            } else {
                nyquistWarning.classList.add('hidden');
            }
            
            // 2. Generate Signals
            const continuousSignal = generateMessageSignal(tContinuous, A_ANALOG, F_ANALOG, funcType);
            const analogSamples = generateMessageSignal(tSamples, A_ANALOG, F_ANALOG, funcType);

            // 3. Run Modulation
            let result;
            let tMod = tSamples; 
            
            if (currentMode === 'PAM') {
                result = simulatePAM(analogSamples);
                tMod = tSamples;
            } else if (currentMode === 'PWM') {
                result = simulatePWM(analogSamples, tContinuous, tSamples);
                tMod = result.time;
            } else if (currentMode === 'PPM') {
                result = simulatePPM(analogSamples, tSamples);
                tMod = result.time;
            } else { 
                result = simulatePAM(analogSamples);
                tMod = tSamples;
                currentMode = 'PAM';
            }
            
            // 4. Run Demodulation
            let demodResult = null;
            if (demodulationEnabled) {
                demodResult = getDemodulatedSignal(result.signal, tMod, currentMode, A_ANALOG, tSamples);
            }

            // Update Title
            let title = result.title;
            if (demodulationEnabled) {
                title = "Demodulation (Recovered Signal Only)";
            }
            document.getElementById('outputGraphTitle').textContent = `2. ${title}`;

            // 5. Draw Results
            drawSinglePlot(canvasInput, ctxInput, continuousSignal, tContinuous, 'INPUT', false, null, null, tSamples, continuousSignal, tContinuous);
            drawSinglePlot(
                canvasOutput, 
                ctxOutput, 
                result.signal, 
                tMod, 
                currentMode, 
                true, 
                demodResult ? demodResult.signal : null, 
                demodResult ? demodResult.time : null,
                tSamples,
                continuousSignal, 
                tContinuous
            );
        }

        // Function to reset all parameters to default values
        function resetToDefaults() {
            A_ANALOG = DEFAULT_A_ANALOG;
            F_ANALOG = DEFAULT_F_ANALOG;
            FS_SAMPLES = DEFAULT_FS_SAMPLES;
            funcType = DEFAULT_FUNC_TYPE;
            currentMode = 'PAM';
            demodulationEnabled = false;

            // Reset UI controls
            document.getElementById('amplitude').value = DEFAULT_A_ANALOG;
            document.getElementById('freqAnalog').value = DEFAULT_F_ANALOG;
            document.getElementById('fsSamples').value = DEFAULT_FS_SAMPLES;
            document.getElementById('funcType').value = DEFAULT_FUNC_TYPE;
            document.getElementById('demodulateSwitch').checked = false;

            // Reset Mode button styling
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            document.querySelector('[data-mode="PAM"]').classList.remove('btn-secondary');
            document.querySelector('[data-mode="PAM"]').classList.add('btn-primary');

            runSimulation();
        }
        
        // --- Event Listeners and Initialization ---
        
        function setupControls() {
            canvasInput = document.getElementById('canvasInput');
            ctxInput = canvasInput.getContext('2d');
            canvasOutput = document.getElementById('canvasOutput');
            ctxOutput = canvasOutput.getContext('2d');
            
            const resizeCanvas = () => {
                const parentInput = canvasInput.parentElement;
                if (parentInput) {
                    canvasInput.width = parentInput.clientWidth;
                    canvasInput.height = parentInput.clientHeight;
                }
                const parentOutput = canvasOutput.parentElement;
                if (parentOutput) {
                    canvasOutput.width = parentOutput.clientWidth;
                    canvasOutput.height = parentOutput.clientHeight;
                }
                runSimulation();
            };
            window.addEventListener('resize', resizeCanvas);
            
            // Modulation Mode Buttons
            document.querySelectorAll('.mode-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const newMode = e.target.getAttribute('data-mode');
                    if (newMode === currentMode) return;

                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.remove('btn-primary');
                        btn.classList.add('btn-secondary');
                    });
                    e.target.classList.remove('btn-secondary');
                    e.target.classList.add('btn-primary');
                    
                    currentMode = newMode;
                    runSimulation();
                });
            });

            // Demodulation Switch
            document.getElementById('demodulateSwitch').addEventListener('change', (e) => {
                demodulationEnabled = e.target.checked;
                runSimulation();
            });
            
            // Reset Button
            document.getElementById('resetButton').addEventListener('click', resetToDefaults);

            // Sliders and Dropdown
            const attachSliderListener = (id, displayId, parseFunc = parseFloat) => {
                const input = document.getElementById(id);
                const valueDisplay = document.getElementById(displayId);

                // Set initial display text based on default JS values
                if (id === 'amplitude') {
                    input.value = A_ANALOG;
                    valueDisplay.textContent = `${A_ANALOG.toFixed(1)} V`;
                } else if (id === 'freqAnalog') {
                    input.value = F_ANALOG;
                    valueDisplay.textContent = `${F_ANALOG.toFixed(1)} Hz`;
                } else if (id === 'fsSamples') {
                    input.value = FS_SAMPLES;
                    valueDisplay.textContent = `${FS_SAMPLES} Hz`;
                }

                input.addEventListener('input', (e) => {
                    const value = parseFunc(e.target.value);
                    
                    if (id === 'amplitude') {
                        A_ANALOG = value;
                        valueDisplay.textContent = `${value.toFixed(1)} V`;
                    } else if (id === 'freqAnalog') {
                        F_ANALOG = value;
                        valueDisplay.textContent = `${value.toFixed(1)} Hz`;
                    } else if (id === 'fsSamples') {
                        FS_SAMPLES = value;
                        valueDisplay.textContent = `${value} Hz`;
                    }
                    
                    requestAnimationFrame(runSimulation);
                });
            };
            
            attachSliderListener('amplitude', 'amplitudeValue');
            attachSliderListener('freqAnalog', 'freqAnalogValue');
            attachSliderListener('fsSamples', 'fsSamplesValue', parseInt);
            
            document.getElementById('funcType').addEventListener('change', (e) => {
                funcType = e.target.value;
                runSimulation();
            });

            // Initial resize and run after all elements are attached
            resizeCanvas();
        }

        window.onload = setupControls; 
    </script>
</body> 
</html>

